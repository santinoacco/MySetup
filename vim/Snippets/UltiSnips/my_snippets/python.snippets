#************************ MOST USEFUL ************************#
snippet #!
#!/usr/bin/env python3
endsnippet
snippet #author
#=============#
# Author: Santiago Noacco Rosende
# Contact: snoaccor@cern.ch
# GitLab:https://gitlab.cern.ch/snoaccor 
# GitHub:https://github.com/santinoacco
#=============#
endsnippet
snippet # "inline comment"
	# -- ${0}
endsnippet
snippet uni
def __unicode__(self):
	${0:representation}
endsnippet
# Imports
snippet imp
import ${0:module}
endsnippet
snippet from
from ${1:package} import ${0:module}
endsnippet
snippet basicimport
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sys
import argparse
endsnippet
snippet rootimport
import ROOT as r
import SwanImports
endsnippet
snippet analyimport
from scipy.optimize import curve_fit
#from iminuit import
endsnippet
# Module Docstring
snippet todo "comment on TODO" b
#   TODO: ${1:desc} - `!v strftime("%c")`
endsnippet
snippet note "NOTE" b
#   NOTE: ${1:desc}   
endsnippet
snippet docs
"""
File: ${1:`vim_snippets#Filename('$1.py', 'foo.py')`}
Author: `g:snips_author`
Email: `g:snips_email`
Github: `g:snips_github`
Description: ${0}
"""
endsnippet
snippet docstring
"""
${0:Description}

# Args::${1:None}

# Returns::${2:${VISUAL}}
"""
endsnippet
# if __name__ == '__main__':
snippet main
import sys
def main(argv):
	parser = config_Parse()
	args = parser.parse_args()	
	${0}

	return
if __name__ == '__main__':
	main(sys.argv[1:])
endsnippet
# argparse 
snippet addarg
parser.add_argument("${0:short_arg}", "${1:long_arg}", required=${2:False}, default=${3:None}, help="${4:Help text}")
endsnippet
snippet configparse
import argparse
def config_Parse():
	"""
	Set all the configuration to your parser object.

	# Args::None

	# Returns::parser object.
	"""
	parser = argparse.ArgumentParser('${0:name}')
	parser.add_argument('-I', '--Input', required=True, help='<${1:Input folder or file/s}>' )
	parser.add_argument('-O', '--Output', required=True, help='<${2:Output folder or files/s}>')
	parser.add_argument('-D','--Debug', required=False, help='Debug flag', action='store_true')
	parser.add_argument('-M','--MaxEvents', required=False, help='Set maximum of events. Default -1 == all', type=int, default=-1)
	return parser
endsnippet
# Blocks
# -- For
snippet for
for ${1:item} in ${2:items}:
	${0}
endsnippet
snippet zip
for ${1:item1}, ${2:item2} in zip(${3:iter1}, ${4:iter2}):
	${0}
endsnippet
# -- Ifs
snippet if
if ${1:condition}:
	${0:${VISUAL}}
endsnippet
snippet el
else:
	${0:${VISUAL}}
endsnippet
snippet ei
elif ${1:condition}:
	${0:${VISUAL}}
endsnippet
# -- With
snippet with
with ${1:expr} as ${2:var}:
	${0:${VISUAL}}
endsnippet
snippet awith "async with"
async with ${1:expr} as ${2:var}:
	${0:${VISUAL}}
endsnippet
# -- Try
snippet try "Try/Except"
try:
	${1:${VISUAL}}
except ${2:Exception} as ${3:e}:
	${0:raise $3}
endsnippet
# Comprehensions
snippet lcp "list comprehension"
[${1} for ${2} in ${3:${VISUAL}}]${0}
endsnippet
snippet dcp "dict comprehension"
{${1}: ${2} for ${3} in ${4:${VISUAL}}}${0}
endsnippet
# Lambda

# Load a path to add libraries
snippet load_lib
from sys.path import insert
insert(0,'${0:path_to_dir}')
endsnippet
# Logging
snippet glog "get log"
import logging
LOGGER = logging.getLogger(${0:__name__})
endsnippet
snippet le
LOGGER.error(${0:msg})
endsnippet
snippet lg
LOGGER.debug(${0:msg})
endsnippet
snippet lw
LOGGER.warning(${0:msg})
endsnippet
snippet lc
LOGGER.critical(${0:msg})
endsnippet
snippet li
LOGGER.info(${0:msg})
endsnippet
# Plots
snippet pltfig
fig, ax = plt.subplots(${0})
endsnippet
snippet axlabels
ax.set_xlabel(${0})
ax.set_ylabel(${1})
endsnippet
snippet add_histo "Loads my default Python 1D Histogram Non Interactive"
endsnippet
snippet add_dinamichisto "Loads my default Python 1D Histogram Interactive"
endsnippet

#****** PyROOT ******#
snippet ini_xaod "in a lxplus env, sets to load xAOD"
r.xAOD.Init().ignore()
endsnippet
snippet Tloadfiles "load files in TChain, requieres configparse" 
ch = r.TChain('${0:VISUAL}')
ch.Add(args.Input)
data = r.xAOD.MakeTransientTree(ch)
${1}
endsnippet
snippet TloopEvs "" b
Events = data.GetEntries()
if verbose: print(f"Input has {Events} total entries")
endsnippet
snippet _TH1F "TH1F template" b
h_${1} = r.TH1F('$1','$1',${2:nbins},${3:min_bin},${4:max_bin})
endsnippet
#****** PySpark ******#
snippet initSpark "starts pySpark session"
from pyspark.sql import SparkSession
spark = SparkSession.builder.appName("${1:NAME}").getOrCreate()
$0
endsnippet
snippet readcsvSpark
spark.read.option(${2:READING_OPTIONS}).csv(${1:PATH},inferSchema=True)
$0
endsnippet

#*************************************************************#
#************************ LESS USEFUL ************************#
# Module Docstring
# Unittest skip
snippet sk "skip unittests" b
@unittest.skip(${1:skip_reason})
endsnippet
# -- Ifs
snippet wh
while ${1:condition}:
	${0:${VISUAL}}
endsnippet
snippet dowh "does the same as do...while in other languages"
while True:
	${1}
	if ${0:condition}:
		break
endsnippet
# New Class
snippet cl
class ${1:ClassName}(${2:object}):
	"""${3:docstring for $1}"""
	def __init__(self, ${4:arg}):
		${5:super($1, self).__init__()}
		self.$4 = $4
		${0}
endsnippet
snippet cla
class ${1:class_name}:
	"""${0:description}"""
endsnippet
snippet clai
class ${1:class_name}:
	"""${2:description}"""
	def __init__(self, ${3:args}):
		${0}
endsnippet
# New Function
snippet def
def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	"""${3:docstring for $1}"""
	${0}
endsnippet
snippet deff
def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	${0}
endsnippet
snippet adef
async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	"""${3:docstring for $1}"""
	${0}
endsnippet
snippet adeff
async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	${0}
endsnippet
# New Method
snippet defi
def __init__(self, ${1:args}):
	${0}
endsnippet
snippet defm
def ${1:mname}(self, ${2:arg}):
	${0}
endsnippet
snippet adefm
async def ${1:mname}(self, ${2:arg}):
	${0}
endsnippet

# New Property
snippet property
def ${1:foo}():
	doc = "${2:The $1 property.}"
	def fget(self):
		${3:return self._$1}
	def fset(self, value):
		${4:self._$1 = value}
	def fdel(self):
		${0:del self._$1}
	return locals()
$1 = property(**$1())
endsnippet
# Encodes
snippet cutf8
# -*- coding: utf-8 -*-
endsnippet
snippet clatin1
# -*- coding: latin-1 -*-
endsnippet
snippet cascii
# -*- coding: ascii -*-
endsnippet
# Lambda
snippet ld
${1:var} = lambda ${2:vars} : ${0:action}
endsnippet
snippet ret
return ${0}
endsnippet
snippet .
self.
endsnippet
# -- Try
snippet trye "Try/Except/Else"
try:
	${1:${VISUAL}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${0}
endsnippet
snippet tryf "Try/Except/Finally"
try:
	${1:${VISUAL}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
finally:
	${0}
endsnippet
snippet tryef "Try/Except/Else/Finally"
try:
	${1:${VISUAL}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${5}
finally:
	${0}
endsnippet
# if __name__ == '__main__':
snippet ifmain
if __name__ == '__main__':
	${0:main()}
endsnippet
# __magic__
snippet _
	__${1:init}__
endsnippet
# python debugger (pdb)
snippet pdb
__import__('pdb').set_trace()
endsnippet
# bpython debugger (bpdb)
snippet bpdb
__import__('bpdb').set_trace()
endsnippet
# ipython debugger (ipdb)
snippet ipdb
__import__('ipdb').set_trace()
endsnippet
# embed ipython itself
snippet iem
__import__('IPython').embed()
endsnippet
# remote python debugger (rpdb)
snippet rpdb
	__import__('rpdb').set_trace()
endsnippet
# web python debugger (wdb)
snippet wdb
	__import__('wdb').set_trace()
endsnippet
# ptpython
snippet ptpython
	__import__('ptpython.repl', fromlist=('repl')).embed(globals(), locals(), vi_mode=${1:False}, history_filename=${2:None})
endsnippet
# python console debugger (pudb)
snippet pudb
	__import__('pudb').set_trace()
endsnippet
# pdb in nosetests
snippet nosetrace
	__import__('nose').tools.set_trace()
endsnippet
snippet pprint
	__import__('pprint').pprint(${1})
endsnippet
snippet "
	"""${0:doc}
	"""
endsnippet
# assertions
snippet a=
	self.assertEqual(${0}, ${1})
endsnippet
snippet assertType "checks type of var."
assert isinstance(${1:var},${2:type}), "Provide $1 as $2"
${0}
endsnippet
# test function/method
snippet test
	def test_${1:description}(${2:`indent('.') ? 'self' : ''`}):
		${0}
endsnippet
# test case
snippet testcase
class ${1:ExampleCase}(unittest.TestCase):

	def test_${2:description}(self):
		${0}
endsnippet
# test given when then
snippet tgwt
# given: ${1}
# when: ${2}
# then: ${3}
endsnippet
snippet fut
	from __future__ import ${0}
endsnippet
#getopt
snippet getopt
	try:
		# Short option syntax: "hv:"
		# Long option syntax: "help" or "verbose="
		opts, args = getopt.getopt(sys.argv[1:], "${1:short_options}", [${2:long_options}])

	except getopt.GetoptError, err:
		# Print debug info
		print str(err)
		${3:error_action}

	for option, argument in opts:
		if option in ("-h", "--help"):
			${0}
		elif option in ("-v", "--verbose"):
			verbose = argument
endsnippet
# argparse
snippet addp
	parser = ${VISUAL:argparse.}ArgumentParser()
endsnippet
snippet addsp
	${0:sub_parser} = parser.add_subparsers().add_parser("${1:name}")
endsnippet
snippet addnarg
	parser.add_argument("${0:arg}", nargs="${1:*}", default"${2:None}, help="${3:Help text}")
endsnippet
snippet addaarg
	parser.add_argument("${0:arg}", "${1:long_arg}", action="${2:store_true}", default=${3:False}, help="${4:Help text}")
endsnippet
snippet pargs
	"${VISUAL:return }"parser.parse_args()
endsnippet

# logging
snippet epydoc
"""${1:Description}

@param ${2:param}: ${3: Description}
@type  $2: ${4: Type}

@return: ${5: Description}
@rtype : ${6: Type}

@raise e: ${0: Description}
"""
endsnippet
snippet dol
def ${1:__init__}(self, *args, **kwargs):
	super(${0:ClassName}, self).$1(*args, **kwargs)
endsnippet
snippet kwg
self.${1:var_name} = kwargs.get('$1', ${2:None})
endsnippet
snippet lkwg
${1:var_name} = kwargs.get('$1', ${2:None})
endsnippet
snippet args
*args${1:,}${0}
endsnippet
snippet kwargs
**kwargs${1:,}${0}
endsnippet
snippet akw
*args, **kwargs${1:,}${0}
endsnippet

# comprehensions
snippet scp "set comprehension"
{${1} for ${2} in ${3:${VISUAL}}}${0}
endsnippet

snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet

snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet

snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}

endsnippet
snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}

endsnippet
snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet

snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet

# time profiling
snippet timeit "time profile"
import time
start = time.perf_counter()
end = time.perf_counter()
total = end - start
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}

def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}

def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}

def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}

def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}

def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}

def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

